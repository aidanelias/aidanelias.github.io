---
layout: post
author: Aidan
technologies: Flutter, Golang, PostgreSQL
img: /assets/images/app-placeholder.jpg
---

I crafted a chat application using Flutter for the frontend and Golang for the backend, chosen specifically for its channels feature. This unique Golang feature facilitated seamless real-time message passing, enhancing the application's responsiveness. I paired this with a Redis database for efficient caching of the most recent messages so new users can stay up to date with the chat, and PostgreSQL database for robust data storage of user credentials.

In today's fast-paced digital world, communication is key. With the rise of mobile applications, creating a chat app has become a popular project for developers looking to enhance their skills and deliver a valuable product. In this blog post, I'll take you through my journey of building a small chat app using Flutter for the frontend, Golang for the backend, Redis for caching messages and PostgreSQL as the user database.

## Backend Architecture:

To ensure modularity, I adopted a microservices architecture for the backend of my chat application. This architectural style breaks down the traditional monolithic structure into smaller, independent services, each handling specific functionalities.

### Chat Service:

The chat service is the heartbeat of the application, responsible for handling message distribution in real-time. Leveraging Golang channels, this service efficiently manages the flow of messages between users, ensuring instant and reliable communication.

#### Redis message caching

When a new client connects to the chat, the Chat Service queries Redis to retrieve the most recent messages. This ensures that the user is not left in the dark and can quickly catch up on the ongoing conversation, fostering a seamless onboarding experience. It is worth noting that this is an in-memory database hosted outside the chat service so should the Redis DB go down for any reason it would mean that new clients would not have access to old messages. While not an ideal experience, I did not think it was worth implementing persistence for such a small feature, however one could move the logic to a database like MongoDB or Postgresql should the feature be deemed important to always be available.

### Token Service:

Authentication is a critical aspect of any application. The token service takes charge of generating secure tokens for user authorization. This microservice ensures that only authenticated users can access the chat functionalities, enhancing the overall security of the application.

#### Token Service Authentication Process:

The Token Service exposes a secure POST **/token** endpoint, where users can authenticate by providing their username and password. The authentication process involves a behind-the-scenes interaction with the User Credentials Service.

##### Authentication Workflow:

- The client sends a POST request to the **/token** endpoint with the username and password.
- The Token Service, upon receiving the request, makes a secure POST request to the User Credentials Service's **/validateUser** endpoint.

###### Interaction with User Credentials Service:

- The **/validateUser** endpoint in the User Credentials Service ensures the correctness of the provided credentials. Upon successful validation, it returns an authorization signal to the Token Service.

##### Token Generation with Golang-JWT:

- With the green light from the User Credentials Service, the Token Service utilizes the Golang-JWT library to generate a secure JWT token.
- The token includes standard JWT claims such as expiration time, issuer, and audience.
- Additionally, a custom claim is added, containing the client's username, providing an extra layer of information for secure token usage.

### Token Introspection Endpoint:

The Token Service's **/introspect** endpoint is designed for inspecting and verifying JWT tokens. This endpoint is vital for ensuring that incoming tokens are legitimate and have not expired.

#### Token Verification Steps:

- The endpoint takes the token in the request body (or header) and performs a series of checks to ensure its validity.
- It checks whether the token was signed using the secret stored in the Token Service, providing a layer of signature verification.
- The presence of the username claim in the token is checked, confirming the association with a valid user.
- Expiry checks ensure that the token has not expired, maintaining the security of the authentication

### User Credentials Service:

Storing and managing user credentials is streamlined through the user credentials service. This microservice interacts with the PostgreSQL database, securely storing and retrieving user information for authentication purposes. The schema for the user credential table in our PostgreSQL database includes fields essential for user management. Each entry is characterized by an 'id,' serving as a unique identifier. The 'username' field stores the chosen user identifier, while the 'password' field securely stores the hashed and encrypted user password. The 'active' status flag indicates the current active state of the user account. Timestamps in the 'created_at' and 'updated_at' fields offer a record of when a user account was created and last updated. This straightforward schema ensures the integrity and security of user data.

## Flutter Frontend

In the Flutter frontend of our chat application, user interaction begins with a login screen, offering a seamless entry point to the engaging world of real-time communication. Users input their credentials, triggering a request to the backend's token endpoint for authentication. Upon successful authentication, a JWT token is returned, marking the key to accessing the group chat. This token is then employed to establish a secure connection to the group chat. Communication in the group chat is facilitated through WebSockets. Messages are sent to the backend and it then distributed on various other sockets for each user in the chat.
